import 'dart:math';
import 'dart:io';
import 'dart:async';

import 'package:gc_wizard/logic/tools/crypto_and_encodings/substitution_breaker/quadgrams/quadgrams.dart';
import 'package:gc_wizard/logic/tools/crypto_and_encodings/substitution_breaker/breaker.dart';
import 'package:gc_wizard/logic/tools/crypto_and_encodings/substitution_breaker/key.dart';

String  _alphabet = null;
List<int> _quadgrams = null;

//@staticmethod
Future<BreakerResult> generate_quadgrams(File corpus_fh, File quadgram_fh, {String alphabet = DEFAULT_ALPHABET}) async {
  /*
        """Static method to generate quadgrams from a text file

        Based on the text file the quadgrams will be serialized in JSON format into
        the file "quadgram_file".

        The quadgrams will be generated by the following steps:

        - the number of occurrences of the quadgram within the text file is counted
          per quadgram
        - if a quadgram does not occur in the text file (i.e. the counted value
          is zero), it will be set to 1/10th of the least often occurring quadgram. This
          is done to allow calculating the logarithm and avoiding "math domain errors"
        - the logarithm of the number of occurrences for each quadgram is calculated
        - the results are normalized (which is not strictly required, but it provides
          fitness values which can be somehow interpreted by humans)

            - to avoid negative values
            - to have a reference point in such a way that value = 100 corresponds to
              "typical occurrences" of the quadgram in the given language. Values below
              100 indicate "less often occurring quadgrams" (the lower the value the
              lesser it will statistically occur), while values above 100 indicate that
              these quadgrams are occurring more often then average in the given
              language. Is that clear enough?

        The quadgrams as well as the used alphabet is then serialized into a JSON
        structure and store in the file "quadgram_file".

        :param corpus_fh: the file handle (i.e., a read()-supporting file like object)
            of the text corpus file to process
        :type corpus_fh: file handle
        :param str quadgram_fh: the file handle (i.e., a write()-supporting file like
            object) where the quadgrams will be serialized to
        :type quadgram_fh: file handle
        :param str alphabet: the alphabet to apply with this text file.
        :raises: ValueError - if the alphabet has more than 32 characters
        """
 */
  _alphabet = Key.check_alphabet(alphabet);
  if (_alphabet.length > Quadgrams.maxAlphabetLength){
    //raise AlphabetInvalid("Alphabet must have less or equal than 32 characters")
    return BreakerResult('','','',_alphabet,0,0,0,0,0,ErrorCode.ALPHABET_TOO_LONG);;
  }


  /*
        var quadgram_val = iterator.iterator.current;
        iterator.iterator.moveNext();
        quadgram_val = (quadgram_val << 5) + iterator.iterator.current;
        iterator.iterator.moveNext();
        quadgram_val = (quadgram_val << 5) + iterator.iterator.current;
        /*var quadgrams = [0 for cntr in range(32 * 32 * 32 * 32)]
         for numerical_char in iterator{
          quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
          quadgrams[quadgram_val] += 1;
          }*/
        List<double> quadgrams = List<double>(32 * 32 * 32 * 32);
        iterator.forEach((numerical_char) {
          quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
          quadgrams[quadgram_val] += 1;
        });
        */
  var iterator = _file_iterator(corpus_fh, _alphabet);
  var quadgrams = List<double>(pow(Quadgrams.maxAlphabetLength, 4));
  var quadgram_val = 0;
  /*
  try {
    quadgram_val = iterator.elementAt(0);
    quadgram_val = (quadgram_val << 5) + iterator.elementAt(1);
    quadgram_val = (quadgram_val << 5) + iterator.elementAt(2);
  } on Exception {
    //except StopIteration:
    //"More than three characters from the given alphabet are required"
    return BreakerResult('','','','',0,0,0,0,0,ErrorCode.WRONG_GENERATE_TEXT);
  } */
  /*var quadgrams = [0 for cntr in range(32 * 32 * 32 * 32)]
         for numerical_char in iterator{
          quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
          quadgrams[quadgram_val] += 1;
          }*/
  var idx = 0;
  try {
    iterator.forEach((numerical_char) {
      switch (idx) {
        case 0:
          quadgram_val = numerical_char;
          break;
        case 1:
        case 2:
          quadgram_val = (quadgram_val << 5) + numerical_char;
          break;
        default:
          quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
          if (quadgrams[quadgram_val] == null)
            quadgrams[quadgram_val] = 1;
          else
            quadgrams[quadgram_val] += 1;
      }
      idx += 1;
    });
  } on Exception {
  //except StopIteration:
  //"More than three characters from the given alphabet are required"
  return BreakerResult('','','','',0,0,0,0,0,ErrorCode.WRONG_GENERATE_TEXT);
  }

  double quadgram_sum = 0;
  double quadgram_min = 10000000; //??
  quadgrams.forEach((val){
    if (val != null && val != 0) {
      quadgram_sum += val;
      quadgram_min = min(quadgram_min, val);
    }
  });
  var offset = log(quadgram_min / 10 / quadgram_sum);

  double prop = 0;
  double new_val = 0;
  double norm = 0;
  idx = 0;
  quadgrams.forEach((val) {
    if (val != null) {
      prop = val / quadgram_sum;
      new_val = log(prop) - offset;
      quadgrams[idx] = new_val; //??
      norm += prop * new_val;
    }
    idx += 1;
  });

  idx = 0;
  quadgrams.forEach((quadgram) {
    if (quadgram != null)
      quadgrams[idx] = (quadgram / norm * 1000); //?? .toDouble()
    idx += 1;
  });

  // Just for curiosity: determine the most frequent quadgram
  idx = 0;
  var max_idx = 0;
  var max_val = 0.0; //??
  quadgrams
    .forEach((val) {
      if (val != null && val > max_val){
        max_val = val;
        max_idx = idx;
      };
      idx += 1;
    });

  // now construct the ASCII representation from the index
  var max_chars = List<String>();
  idx = max_idx;
  /*        for _ in range(4){
            max_chars = [alphabet[index & 0x1F]] + max_chars;
            index >>= 5
				};
				*/
  for (int i = 0; i < 4; i++) {
    max_chars.insert(0, alphabet[idx & 0x1F]); //+ max_chars ??????
    idx >>= 5;
  }

  return _generateFile(quadgram_fh, alphabet, quadgram_sum, max_chars.join(), max_val, quadgrams);
}

BreakerResult _generateFile(File quadgram_fh, String alphabet, double quadgram_sum, String max_chars, double max_val, List<double> quadgrams){
  var sb = new StringBuffer();
  sb.write("import 'package:gc_wizard/logic/tools/crypto_and_encodings/substitution_breaker/quadgrams/quadgrams.dart';\n");
  sb.write("\n");
  sb.write("class XXX implements Quadgrams {\n");
  sb.write("\n");
  sb.write("XXX(){}\n");
  sb.write("\n");
  sb.write("final String alphabet = '" + alphabet + "';\n");
  sb.write("final int nbr_quadgrams = " + quadgram_sum.round().toString() +";\n");
  sb.write("final String most_frequent_quadgram = '" + max_chars + "';\n");
  sb.write("final int max_fitness = " + max_val.round().toString() + ";\n");
  sb.write("final double average_fitness = " + (sum(quadgrams) / pow(alphabet.length, 4 )).toString() + ";\n");
  sb.write("final double quadgrams_sum = " + sum(quadgrams).toString() + ";\n");
  sb.write("final List<int> quadgrams = [");
  sb.write("\n");

  bool first = true;
  var idx  = 0;
  String out ='';
  quadgrams.forEach((val) {
    if (first) first = false;
    else sb.write(',');
    if (val == null) val = 0;
    out = val.round().toString();
    sb.write(out);
    idx += out.length + 1;
    if (idx > 230) {
      sb.write("\n");
      idx = 0;
    }
  });
  sb.write("\n]\n");
  sb.write("}\n");

  quadgram_fh.writeAsStringSync(sb.toString());

  var test = Map <int,List<int>>();

  return BreakerResult('','','',alphabet,max_val,0,0,0,0,ErrorCode.OK);
/*
json.dump(
            {
                "alphabet": alphabet,
                "nbr_quadgrams": quadgram_sum,
                "most_frequent_quadgram": "".join(max_chars),
                "max_fitness": max_val,
                "average_fitness": sum(quadgrams) / (len(alphabet) ** 4),
                "quadgrams": quadgrams,
            },
            quadgram_fh,
            indent=0,
        )
        BreakerInfo(

                alphabet,
                quadgram_sum.toInt(),
                max_chars.join(),
                max_val,
                //quadgrams,
          0
        );
            quadgram_fh,
            indent=0,
        );


 */
}

double _calc_fitness(Iterable<int> iterator){
  /*
        """Calculate the fitness from the characters provided by the iterator

        :param iterator: iterator which provides the characters relevant for
            calculating the fitness
        :param type: iterator object
        :return: the fitness of the text. A value close to 100 means, the
            text is probably in the same language than the language used to generate
            the quadgrams. The more the value differs from 100, the lesser the
            probability that the examined text corresponds to the quadgram language.
            Lower values indicate more random text, while values significantly
            greater than 100 indicate (nonsense) text with too much frequently used
            quadgrams (e.g., ``tionioningatheling``).
        :rtype: float
        :raises: ValueError
        """
        */
  /*
        try {

          var quadgram_val = iterator.current;
          iterator.moveNext();
          quadgram_val = (quadgram_val << 5) + iterator.current;
          iterator.moveNext();
          quadgram_val = (quadgram_val << 5) + iterator.current;
        } on Exception {
          //except StopIteration:
          //"More than three characters from the given alphabet are required"
          return null;
        };

        fitness = 0
        nbr_quadgrams = 0
        var quadgrams = _quadgrams;

        for numerical_char in iterator{
            quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
            fitness += quadgrams[quadgram_val];
            nbr_quadgrams += 1;
        }

         */
  var quadgrams = _quadgrams;
  var fitness = 0;
  var nbr_quadgrams = 0;
  var quadgram_val=0;
  try {
    quadgram_val = iterator.iterator.current;
    iterator.iterator.moveNext();
    quadgram_val = (quadgram_val << 5) + iterator.iterator.current;
    iterator.iterator.moveNext();
    quadgram_val = (quadgram_val << 5) + iterator.iterator.current;
  } on Exception {
    //except StopIteration:
    //"More than three characters from the given alphabet are required"
    return null;
  }

  iterator.forEach((numerical_char) {
    quadgram_val = ((quadgram_val & 0x7FFF) << 5) + numerical_char;
    fitness += quadgrams[quadgram_val];
    nbr_quadgrams += 1;
  });

  if (nbr_quadgrams == 0){
    //raise ValueError(
    //    "More than three characters from the given alphabet are required")
    return null;
  }
  return fitness / nbr_quadgrams / 10;
}

calc_fitness(String txt) {
/*        """Method to calculate the fitness for the given text string

        :param str txt: the text string for which the fitness shall be determined
        :return: the fitness of the text. A value close to 100 means, the
            text is probably in the same language than the language used to generate
            the quadgrams. The more the value differs from 100, the lesser the
            probability that the examined text corresponds to the quadgram language.
            Lower values indicate more random text, while values significantly
            greater than 100 indicate (nonsense) text with too much frequently used
            quadgrams (e.g., ``tionioningatheling``).
        :rtype: float
        """
 */
  return _calc_fitness(iterateText(txt, _alphabet));
}

//@staticmethod
Iterable<int> _file_iterator(File file_fh, String alphabet)  sync*  {
  /*
        """Implements an iterator for a given file based text file

        The iterator will yield all charcters of the text file which are present in
        the alphabet, all other characters will be skipped.

        :param file_fh: the file handle (i.e., a read()-supporting file like object)
            of the text file
        :type file_fh: file handle
        :param str alphabet: the alphabet to apply with this text file.
        :return: an iterator which iterates over all characters of the text file
            which are present in the alphabet.
        """

                var trans = {val: key for key, val in enumerate(alphabet.lower())};
        for line in file_fh{
            line = line.lower();
            for char in line{
                val = trans.get(char)
                if val is not None{
                    yield val;
                }
           }
        }
*/
  String text = file_fh.readAsStringSync();
  //file_fh.readAsString().then((String text) {
    //iterateText(text, alphabet);
  // });

  var trans = alphabet.toLowerCase();
  int index = -1;

  text = text.toLowerCase();
  for (int i = 0; i < text.length; i++) {
    index = trans.indexOf(text[i]);
    if (index >= 0)
      yield index;
  }

}

double calc_fitness_file(File cleartext_fh){
/*        """Method to calculate the fitness of the given file contents

        :param cleartext_fh: the file handle (i.e., a read()-supporting file like
            object) from which the fitness will be calculated
        :type cleartext_fh: file handle
        :return: the fitness of the text. A value close to 100 means, the
            text is probably in the same language than the language used to generate
            the quadgrams. The more the value differs from 100, the lesser the
            probability that the examined text corresponds to the quadgram language.
            Lower values indicate more random text, while values significantly
            greater than 100 indicate (nonsense) text with too much frequently used
            quadgrams (e.g., ``tionioningatheling``).
        :rtype: float
        """
        */

  return _calc_fitness(_file_iterator(cleartext_fh, _alphabet));
}

double sum(List<double> list) {
  double sum = 0;
  list.forEach((val) { if(val != null) sum += val.round();});
  return sum;
}
